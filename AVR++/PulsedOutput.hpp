#pragma once

#include "Const.hpp"
#include "IOpin.hpp"
#include "Nop.hpp"

namespace AVR {

// enum class InterruptHandling {
//   None,
//   Bit,
//   Byte,
//   Block,
// };

/**
 * @brief Output that can handle a pulse length encoded bit digital protocol
 *
 * A single bit is a high "pulse" period and low "pulse" period.
 *
 * A longer pulse is a "1" bit and a shorter pulse is a "0" bit.
 *
 * @details
 *          _______________________
 *     0 = |<-- ShortPulseNanos -->|<-- MinRecoveryNanos -->
 *         |                       |________________________
 *          __________________________________
 *     1 = |<-------- LongPulseNanos -------->|<-- MinRecoveryNanos -->
 *         |                                  |________________________
 *
 * @tparam Port The processor "Port" to use
 * @tparam Pin The partiular Pin of the "Port" to use
 * @tparam ShortPulseNanos The length of the short pulse in nanoseconds
 * @tparam InvertedOutput Whether to invert the output (false)
 * @tparam LongPulseNanos The length of the long pulse in nanoseconds (2x short pulse)
 * @tparam LittleEndian Whether to send the least significant bit first (false)
 * @tparam InvertBits Whether to invert the long/short pulse meaning of bits (false)
 * @tparam MinRecoveryNanos The minimum time to wait after sending a bit before sending the next bit (0)
 * @tparam BalanceRecoveryTimes Make pulses start at regular intervals (false) [Not Yet Implemented]
 */
template <Ports Port, unsigned Pin, unsigned ShortPulseNanos, bool InvertedOutput = false,
          unsigned LongPulseNanos = ShortPulseNanos * 2, bool LittleEndian = false, bool InvertBits = false,
          unsigned MinRecoveryNanos = ShortPulseNanos, bool BalanceRecoveryTimes = false>
class PulsedOutput : protected Output<Port, Pin, InvertedOutput> {
protected:
  using Output<Port, Pin, InvertedOutput>::on;
  using Output<Port, Pin, InvertedOutput>::off;
  using Output<Port, Pin, InvertedOutput>::input;
  using Output<Port, Pin, InvertedOutput>::output;

public:
  using Output<Port, Pin, InvertedOutput>::init;

  // Positive length of output on for "0" bit (for non-inverted output/bits)
  static constexpr double pulseLengthShort = 0.000000001 * ShortPulseNanos;
  // Positive length of output on for "1" bit
  static constexpr double pulseLengthLong = 0.000000001 * LongPulseNanos;
  // Minimum length of off state
  static constexpr double pulseLengthRecover = 0.000000001 * MinRecoveryNanos;

  // Cycles needed by microprocessor to achieve the desired periods
  static constexpr unsigned cyclesShort = const_round(F_CPU * pulseLengthShort);
  static constexpr unsigned cyclesLong = const_round(F_CPU * pulseLengthLong);
  static constexpr unsigned cyclesRecover = const_round(F_CPU * pulseLengthRecover);

  /**
   * In order to get accurate transition times, we need to know how long other intructions that are used/executed take.
   * To get these values, we need to inspect the generated assembly and count the number of instructions the compiler
   * generated. The remaining time is filled with NOPs.
   */

  /**
   * Let's step through the assembly code generated by the compiler.
   *
   * Each line is one clock cycle. It's a "0" bit followed by a "1" bit.
   *
   * C++       // ASM simplified ; Out Notes
   * --------- // -------------- ; --- --------
   * byte <<=  // lsr            ; 0   Top of Loop - Shift data and store carry bit ("0" this time)
   * on()      // sbi	Port,Pin   ; 1   Turn on output
   * delay(A)  // nop x A        ; 1   Delay A - adjust to get the "0" timing we want
   * if (bit)  // brcs off()     ; 1   test bit. is low. needs no extra delay. Takes 1 cycle without branch.
   * off()     // cbi Port,Pin   ; 0   Turn off
   * delay(C)  // nop x C        ; 0   Delay C - adjust to get the minimum off timing we want
   * len--     // subi           ; 0   Decrement byte length counter
   * if (len)  // brne           ; 0   if not zero, jump back to start of loop
   *                             ; 0   brne takes 2 clock cycles when branching (looping)
   * byte <<=  // lsr            ; 0   Top of Loop - Shift data and store carry bit ("1" this time)
   * on()      // sbi	Port,Pin   ; 1   Turn on output
   * delay(A)  // nop x A        ; 1   Delay A - adjust to get the "0" timing we want
   * if (bit)  // brcs off()     ; 1   test bit. is high. needs extra delay. branch to DelayB.
   *                             ; 1   brcs takes 2 clock cycles when branching
   * delay(B)  // nop x B        ; 1   Delay B - adjust to get the "1" timing we want
   * goto      // rjmp Off()     ; 1   Jump to off
   *                             ; 1   rjmp takes 2 clock cycles
   * off()     // cbi Port,Pin   ; 0   Turn off
   * ...
   *
   * So, now we count how many clock cycles the output stays on, for each value.
   *
   * The high time for a "0" is 3 lines, but includes one line for delay A. So minCyclesShort = 2
   * The high time for a "1" is 7 lines, but includes lines delay A and B. So minCyclesLong = 5
   * The low time for the inner loop is 6 lines, but includes the delay C. So minCyclesRecover = 5
   *
   * The outer loop (asm not shown) adds 7 clock cycles to the low period every byte. So outerLoopExtraCycles = 7
   * So long as it doesn't stretch the low time too much, the data should not be corrupted.
   *
   * Let's use some basic arithmetic. Starting with...
   * cyclesShort = minCyclesShort + A
   * cyclesLong = minCyclesLong + A + B
   * cyclesLow = minCyclesRecover + C
   * cyclesLowLoop = cyclesLow + outerLoopExtraCycles
   *
   * We can rearrange the equations to get...
   *
   * delayCyclesA = cyclesShort - minCyclesShort
   * delayCyclesB = cyclesLong - minCyclesLong - delayCyclesA
   * delayCyclesC = cyclesLow - minCyclesRecover
   */

  // The number of instructions it takes to turn on the output and possibly skip the second delay

  static constexpr unsigned minCyclesShort = 2;
  static constexpr unsigned minCyclesLong = 5;
  static constexpr unsigned minCyclesRecover = 5;
  static constexpr unsigned outerLoopExtraCycles = 7;

  static constexpr unsigned delayCyclesA = max<signed>(0, cyclesShort - minCyclesShort);
  static constexpr unsigned delayCyclesB = max<signed>(0, cyclesLong - minCyclesLong - delayCyclesA);
  static constexpr unsigned delayCyclesC = max<signed>(0, cyclesRecover - minCyclesRecover);

  // Values that will actually be used. For developer inspection with modern editor.

  static constexpr auto realHighCyclesShort = minCyclesShort + delayCyclesA;
  static constexpr auto realHighCyclesLong = minCyclesLong + delayCyclesA + delayCyclesB;
  static constexpr auto realLowCyclesMin = minCyclesRecover + delayCyclesC;
  static constexpr auto realLowCyclesMax = realLowCyclesMin + outerLoopExtraCycles;

  static constexpr auto realHighTimeShort = realHighCyclesShort / double(F_CPU);
  static constexpr auto realHighTimeLong = realHighCyclesLong / double(F_CPU);
  static constexpr auto realLowTimeMin = realLowCyclesMin / double(F_CPU);
  static constexpr auto realLowTimeMax = realLowCyclesMax / double(F_CPU);

  static constexpr auto realHighNanosecondsShort = realHighTimeShort * 1e9;
  static constexpr auto realHighNanosecondsLong = realHighTimeLong * 1e9;
  static constexpr auto realLowNanosecondsMin = realLowTimeMin * 1e9;

  static constexpr auto realLowMicrosecondsMax = realLowTimeMax * 1e6;

public:
  static void send(u1 byte, u1 bits = 8);

  /**
   * @brief Shift an array of bits (packed as bytes) out the specified pin
   *
   * @param data the bytes to send
   * @param bytes the number of bytes to send
   */
  static inline void send(u1 const *data, u1 bytes) {
    while (bytes--)
      send(*data++);
  }
};

}; // namespace AVR