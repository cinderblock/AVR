#pragma once

#include "Const.hpp"
#include "IOpin.hpp"

namespace AVR {

// enum class InterruptHandling {
//   None,
//   Bit,
//   Byte,
//   Block,
// };

/**
 * @brief Output that can handle a pulse length encoded bit digital protocol
 *
 * A single bit is a high "pulse" period and low "pulse" period.
 *
 * A longer pulse is a "1" bit and a shorter pulse is a "0" bit.
 *
 * @details
 *          _______________________
 *     0 = |<-- shortPulseNanos -->|<-- minRecoveryNanos -->
 *         |                       |________________________
 *          __________________________________
 *     1 = |<-------- longPulseNanos -------->|<-- minRecoveryNanos -->
 *         |                                  |________________________
 *
 * @tparam port The processor "port" to use
 * @tparam pin The partiular pin of the "port" to use
 * @tparam shortPulseNanos The length of the short pulse in nanoseconds
 * @tparam InvertedOutput Whether to invert the output (false)
 * @tparam longPulseNanos The length of the long pulse in nanoseconds (2x short pulse)
 * @tparam LittleEndian Whether to send the least significant bit first (false)
 * @tparam InvertBits Whether to invert the long/short pulse meaning of bits (false)
 * @tparam minRecoveryNanos The minimum time to wait after sending a bit before sending the next bit (0)
 * @tparam balanceRecoveryTimes Make pulses start at regular intervals (false) [Not Yet Implemented]
 */
template <Ports port, u1 pin, unsigned shortPulseNanos, bool InvertedOutput = false,
          unsigned longPulseNanos = shortPulseNanos * 2, bool LittleEndian = false, bool InvertBits = false,
          unsigned minRecoveryNanos = shortPulseNanos, bool balanceRecoveryTimes = false>
class PulsedOutput : protected Output<port, pin, InvertedOutput> {
protected:
  using Output<port, pin>::on;
  using Output<port, pin>::off;

public:
  // Positive length of output on for "0" bit (for non-inverted output/bits)
  consteval double pulseLength0 = 0.000000001 * shortPulseNanos;
  // Positive length of output on for "1" bit
  consteval double pulseLength1 = 0.000000001 * longPulseNanos;
  // Minimum length of off state
  consteval double pulseLengthR = 0.000000001 * minRecoveryNanos;

  // Cycles needed by microprocessor to achieve the desired periods
  consteval unsigned cycles0 = const_round(F_CPU * pulseLength0);
  consteval unsigned cycles1 = const_round(F_CPU * pulseLength1);
  consteval unsigned cyclesR = const_round(F_CPU * pulseLengthR);

  /**
   * In order to get accurate transition times, we need to know how long other intructions that are used/executed take.
   * To get these values, we need to inspect the generated assembly and count the number of instructions the compiler
   * generated. The remaining time is filled with NOPs.
   */

  /**
   * Let's step through the assembly code generated by the compiler.
   *
   * Each line is one clock cycle. It's a "0" bit followed by a "1" bit.
   *
   * C++       // ASM simplified ; Out Notes
   * --------- // -------------- ; --- --------
   * byte <<=  // lsr            ; 0   Top of Loop - Shift data and store carry bit ("0" this time)
   * on()      // sbi	Port,Pin   ; 1   Turn on output
   * delay(A)  // nop x A        ; 1   Delay A - adjust to get the "0" timing we want
   * if (bit)  // brcs off()     ; 1   test bit. is low. needs no extra delay. Takes 1 cycle without branch.
   * off()     // cbi Port,Pin   ; 0   Turn off
   * delay(C)  // nop x C        ; 0   Delay C - adjust to get the minimum off timing we want
   * len--     // subi           ; 0   Decrement byte length counter
   * if (len)  // brne           ; 0   if not zero, jump back to start of loop
   *                             ; 0   brne takes 2 clock cycles when branching (looping)
   * byte <<=  // lsr            ; 0   Top of Loop - Shift data and store carry bit ("1" this time)
   * on()      // sbi	Port,Pin   ; 1   Turn on output
   * delay(A)  // nop x A        ; 1   Delay A - adjust to get the "0" timing we want
   * if (bit)  // brcs off()     ; 1   test bit. is high. needs extra delay. branch to DelayB.
   *                             ; 1   brcs takes 2 clock cycles when branching
   * delay(B)  // nop x B        ; 1   Delay B - adjust to get the "1" timing we want
   * goto      // rjmp Off()     ; 1   Jump to off
   *                             ; 1   rjmp takes 2 clock cycles
   * off()     // cbi Port,Pin   ; 0   Turn off
   * ...
   *
   * So, now we count how many clock cycles the output stays on, for each value.
   *
   * The high time for a "0" is 3 lines, but includes one line for delay A. So minCycles0 = 2
   * The high time for a "1" is 7 lines, but includes lines delay A and B. So minCycles1 = 5
   * The low time for the inner loop is 6 lines, but includes the delay C. So minCyclesR = 5
   *
   * The outer loop (asm not shown) adds 7 clock cycles to the low period every byte. So outerLoopExtraCycles = 7
   * So long as it doesn't stretch the low time too much, the data should not be corrupted.
   *
   * Let's use some basic arithmetic. Starting with...
   * cycles0 = minCycles0 + A
   * cycles1 = minCycles1 + A + B
   * cyclesLow = minCyclesR + C
   * cyclesLowLoop = cyclesLow + outerLoopExtraCycles
   *
   * We can rearrange the equations to get...
   *
   * delayCyclesA = cycles0 - minCycles0
   * delayCyclesB = cycles1 - minCycles1 - delayCyclesA
   * delayCyclesC = cyclesLow - minCyclesR
   */

  // The number of instructions it takes to turn on the output and possibly skip the second delay

  consteval unsigned minCycles0 = 2;
  consteval unsigned minCycles1 = 5;
  consteval unsigned minCyclesR = 5;
  consteval unsigned outerLoopExtraCycles = 7;

  consteval unsigned delayCyclesA = max<signed>(0, cycles0 - minCycles0);
  consteval unsigned delayCyclesB = max<signed>(0, cycles1 - minCycles1 - delayCyclesA);
  consteval unsigned delayCyclesC = max<signed>(0, cyclesR - minCyclesR);

  // Values that will actually be used. For developer inspection with modern editor.

  consteval auto realHighCycles0 = minCycles0 + delayCyclesA;
  consteval auto realHighCycles1 = minCycles1 + delayCyclesA + delayCyclesB;
  consteval auto realLowCyclesMin = minCyclesR + delayCyclesC;
  consteval auto realLowCyclesMax = realLowCyclesMin + outerLoopExtraCycles;

  consteval auto realHighTime0 = realHighCycles0 / double(F_CPU);
  consteval auto realHighTime1 = realHighCycles1 / double(F_CPU);
  consteval auto realLowTimeMin = realLowCyclesMin / double(F_CPU);
  consteval auto realLowTimeMax = realLowCyclesMax / double(F_CPU);

  consteval auto realHighNanoseconds0 = realHighTime0 * 1e9;
  consteval auto realHighNanoseconds1 = realHighTime1 * 1e9;
  consteval auto realLowNanosecondsMin = realLowTimeMin * 1e9;

  consteval auto realLowMicrosecondsMax = realLowTimeMax * 1e6;

public:
  static inline void send(u1 const byte, u1 bits = 8);

  /**
   * @brief Shift an array of bits (packed as bytes) out the specified pin
   *
   * @param bytes the bytes to send
   * @param bits the number of bits to send
   */
  static inline void send(u1 const *bytes, u2 bits);
};

}; // namespace AVR