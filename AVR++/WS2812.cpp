#include "WS2812.hpp"
#include "Nop.hpp"
#include <util/delay.h>

using namespace AVR;

template <typename T> static constexpr int const_round(T f) { return f > 0.0 ? int(f + 0.5) : int(f - 0.5); }
template <typename T> static constexpr T max(T a, T b) { return a > b ? a : b; }

template <Ports Port, u1 Pin, bool HandleInterrupts, unsigned ResetMicroseconds, bool InvertedLogic, bool LittleEndian>
void WS2812<Port, Pin, HandleInterrupts, ResetMicroseconds, InvertedLogic, LittleEndian>::setLEDs(RGB const *leds,
                                                                                                  u2 pixels) {
  sendBytes((u1 const *)leds, pixels * sizeof(*leds));
  _delay_us(ResetMicroseconds);
}

template <Ports Port, u1 Pin, bool HandleInterrupts, unsigned ResetMicroseconds, bool InvertedLogic, bool LittleEndian>
void WS2812<Port, Pin, HandleInterrupts, ResetMicroseconds, InvertedLogic, LittleEndian>::setLEDs(RGBW const *leds,
                                                                                                  u2 pixels) {
  sendBytes((u1 const *)leds, pixels * sizeof(*leds));
  _delay_us(ResetMicroseconds);
}

/**
 * A single WS2812 bit is a high "pulse" period and low "pulse" period.
 *
 * A longer high pulse is a "1" bit and a shorter high pulse is a "0" bit.
 *
 * The spec says that the pulses are 0.4µs and 0.8µs (+/- 150ns) respectively.
 * It also specifies a negative time to make each bit the same length overall.
 *
 *  ________400ns________
 * |                     |
 * |                     |                                         = 0
 * |                     |_________________850ns__________________
 *
 *  ___________________800ns_________________
 * |                                         |
 * |                                         |                     = 1
 * |                                         |________450ns_______
 *
 * In practice, the length of time the data line is low does not matter as long as it's long enough that pixels "see" it
 * and not so long that it's "seen" as a reset pulse. To put it another way, there is no reason to wait the full 850ns
 * for a "0". This simplification of the protocol is easier to implement. This also lets the code gracefully take a
 * different amount of time when at the end of a byte.
 */

// Positive length of output on for "0" bit
constexpr double pulseLength0 = 0.000000400;
// Positive length of output on for "1" bit
constexpr double pulseLength1 = 0.000000800;
// Minimum length of off state
constexpr double pulseLengthL = 0.000000450;

// Cycles needed by microprocessor to achieve the desired periods
constexpr unsigned cycles0 = const_round(F_CPU * pulseLength0);
constexpr unsigned cycles1 = const_round(F_CPU * pulseLength1);
constexpr unsigned cyclesL = const_round(F_CPU * pulseLengthL);

/**
 * In order to get accurate transition times, we need to know how long other intructions that are used/executed take.
 * To get these values, we need to inspect the generated assembly and count the number of instructions the compiler
 * generated. The remaining time is filled with NOPs.
 */

/**
 * Let's step through the assembly code generated by the compiler.
 *
 * Each line is one clock cycle. It's a "0" bit followed by a "1" bit.
 *
 * C++       // ASM simplified ; Out Notes
 * --------- // -------------- ; --- --------
 * byte <<=  // lsr            ; 0   Top of Loop - Shift data and store carry bit ("0" this time)
 * on()      // sbi	Port,Pin   ; 1   Turn on output
 * delay(A)  // nop x A        ; 1   Delay A - adjust to get the "0" timing we want
 * if (bit)  // brcs off()     ; 1   test bit. is low. needs no extra delay. Takes 1 cycle without branch.
 * off()     // cbi Port,Pin   ; 0   Turn off
 * delay(C)  // nop x C        ; 0   Delay C - adjust to get the minimum off timing we want
 * len--     // subi           ; 0   Decrement byte length counter
 * if (len)  // brne           ; 0   if not zero, jump back to start of loop
 *                             ; 0   brne takes 2 clock cycles when branching (looping)
 * byte <<=  // lsr            ; 0   Top of Loop - Shift data and store carry bit ("1" this time)
 * on()      // sbi	Port,Pin   ; 1   Turn on output
 * delay(A)  // nop x A        ; 1   Delay A - adjust to get the "0" timing we want
 * if (bit)  // brcs off()     ; 1   test bit. is high. needs extra delay. branch to DelayB.
 *                             ; 1   brcs takes 2 clock cycles when branching
 * delay(B)  // nop x B        ; 1   Delay B - adjust to get the "1" timing we want
 * goto      // rjmp Off()     ; 1   Jump to off
 *                             ; 1   rjmp takes 2 clock cycles
 * off()     // cbi Port,Pin   ; 0   Turn off
 * ...
 *
 * So, now we count how many clock cycles the output stays on, for each value.
 *
 * The high time for a "0" is 3 lines, but includes one line for delay A. So minCycles0 = 2
 * The high time for a "1" is 7 lines, but includes lines delay A and B. So minCycles1 = 5
 * The low time for the inner loop is 6 lines, but includes the delay C. So minCyclesL = 5
 *
 * The outer loop (asm not shown) adds 7 clock cycles to the low period every byte. So outerLoopExtraCycles = 7
 * So long as it doesn't stretch the low time too much, the data should not be corrupted.
 *
 * Let's use some basic arithmetic. Starting with...
 * cycles0 = minCycles0 + A
 * cycles1 = minCycles1 + A + B
 * cyclesLow = minCyclesL + C
 * cyclesLowLoop = cyclesLow + outerLoopExtraCycles
 *
 * We can rearrange the equations to get...
 *
 * delayCyclesA = cycles0 - minCycles0
 * delayCyclesB = cycles1 - minCycles1 - delayCyclesA
 * delayCyclesC = cyclesLow - minCyclesL
 */

// The number of instructions it takes to turn on the output and possibly skip the second delay

constexpr unsigned minCycles0 = 2;
constexpr unsigned minCycles1 = 5;
constexpr unsigned minCyclesL = 5;
constexpr unsigned outerLoopExtraCycles = 7;

constexpr unsigned delayCyclesA = max<signed>(0, cycles0 - minCycles0);
constexpr unsigned delayCyclesB = max<signed>(0, cycles1 - minCycles1 - delayCyclesA);
constexpr unsigned delayCyclesC = max<signed>(0, cyclesL - minCyclesL);

// Values that will actually be used. For developer inspection with modern editor.

constexpr auto realHighCycles0 = minCycles0 + delayCyclesA;
constexpr auto realHighCycles1 = minCycles1 + delayCyclesA + delayCyclesB;
constexpr auto realLowCyclesMin = minCyclesL + delayCyclesC;
constexpr auto realLowCyclesMax = realLowCyclesMin + outerLoopExtraCycles;

constexpr auto realHighTime0 = realHighCycles0 / double(F_CPU);
constexpr auto realHighTime1 = realHighCycles1 / double(F_CPU);
constexpr auto realLowTimeMin = realLowCyclesMin / double(F_CPU);
constexpr auto realLowTimeMax = realLowCyclesMax / double(F_CPU);

constexpr auto realHighNanoseconds0 = realHighTime0 * 1e9;
constexpr auto realHighNanoseconds1 = realHighTime1 * 1e9;
constexpr auto realLowNanosecondsMin = realLowTimeMin * 1e9;

constexpr auto realLowMicrosecondsMax = realLowTimeMax * 1e6;

static_assert(realHighNanoseconds0 <= 400 + 150, "Short pulse period is too long. Check F_CPU and WS2812 timing.");

template <Ports Port, u1 Pin, bool HandleInterrupts, unsigned ResetMicroseconds, bool InvertedLogic, bool LittleEndian>
void WS2812<Port, Pin, HandleInterrupts, ResetMicroseconds, InvertedLogic, LittleEndian>::sendBytes(u1 const *data,
                                                                                                    u2 length) {
  if (HandleInterrupts)
    asm("cli");

  while (length--) {
    u1 current = *data++;
    u1 byteLen = 8;
    while (byteLen--) {
      // Mutates carry flag which we check later
      if (LittleEndian)
        asm volatile("lsr %0" : "+r"(current)); // current >>= 1;
      else
        asm volatile("lsl %0" : "+r"(current)); // current <<= 1;

      on();

      asm("; Delay A = %0 cycles" : : "I"(delayCyclesA));
      nopCycles(delayCyclesA);
      asm("; End of Delay A");

      // BRanch if Carry is Set (sending a "1")
      // delayB();
      asm volatile("brcs DELAYB");
      // We use brcs because when it falls through (sending a "0"), it only takes 1 clock cycle.
      // This enables the minimum on time of 2 clock cycles.

      asm("OFF_JUMP:");
      off();

      asm("; Delay C = %0 cycles" : : "I"(delayCyclesC));
      nopCycles(delayCyclesC);
      asm("; End of Delay C");
    }
  }

  if (HandleInterrupts)
    asm("reti");
  else
    asm("ret");

  asm("DELAYB:");
  asm("; Delay B = %0 cycles" : : "I"(delayCyclesB));
  nopCycles(delayCyclesB);
  asm("; End of Delay B");

  // Get back to the normal loop
  asm volatile("rjmp OFF_JUMP");

  // This test depends on `ResetMicroseconds` so it needs to be inside a templated function.
  static_assert(realLowMicrosecondsMax < ResetMicroseconds / 2,
                "Low period is too long and could be considered a \"reset\". "
                "Check F_CPU and WS2812 timing.");
}
